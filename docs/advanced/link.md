# 链接

## 链接器

对于大多数编译器来说，每个目标文件都是编译一个输入源代码文件的结果。当一个程序包含多个目标文件时，链接器将这些文件组合成一个统一的可执行程序，在执行过程中解析符号

特性

- 链接器可以从称为库或运行时库的集合中获取对象
- 大多数链接器不会在输出可执行文件中包含静态库中的所有目标文件
- 链接器只包括库中那些被其他目标文件或库直接或间接引用的目标文件
- 但是对于共享库，必须在运行时加载整个库，因为不知道在运行时将调用哪些函数或方法
- 链接器还负责在程序的地址空间中排列对象。这可能涉及将假定特定基地址的代码重新定位到另一个基中。由于编译器很少知道对象将驻留在哪里，它通常假定一个固定的基位置（例如，零）。重新定位机器代码可能涉及重新定位绝对跳转、加载和存储
- 链接器的可执行输出在最终加载到内存时（就在执行之前）可能需要另一个重定位传递。在提供虚拟内存的硬件上通常省略此传递：每个程序都被放入自己的地址空间中，因此即使所有程序加载在相同的基地址上也没有冲突。如果可执行文件是与位置无关的可执行文件，则此传递也可以省略
- 在某些操作系统中，同一个程序同时处理链接和加载程序的作业

## 静态链接

静态链接是链接器将程序中使用的所有库复制到可执行程序的过程

任何静态库函数都可以调用另一个静态库中的函数或过程。链接器和加载器处理这一点的方式与处理其他类型的目标文件的方式相同。静态库文件可以在运行时由链接加载器链接，然而这样的过程是否可以称为静态链接是有争议的

静态链接优点：

- 可执行文件包含了所有所需的库，因此不需要额外的库文件
- 程序启动速度更快，因为所有库都已经加载到内存中
- 静态链接的可执行文件通常更小，因为它们不包含库的副本

静态链接缺点：

- 如果库更新，所有使用该库的程序都必须重新链接
- 如果多个程序使用相同的库，那么每个程序都将包含该库的副本，这可能导致重复数据
- 静态链接的可执行文件通常需要更多的内存，因为每个程序都包含库的副本

创建静态库：

静态库文件名通常在类Unix系统[上具有“. a”扩展名，在Microsoft Windows上具有“.lib”扩展名

## 动态链接

动态链接器是操作系统的一部分，加载，链接可执行文件在执行时所需的共享库，通过将库的内容从持久存储复制到RAM，填充跳转表并重新定位指针。特定的操作系统和可执行格式决定了动态链接器的功能和实现方式

动态链接优点：

- 常用的库（例如标准系统库）只需要存储在一个位置，而不是在每个可执行文件中重复，从而节省有限的内存和磁盘空间
- 如果通过替换库来纠正库函数中的bug或提高性能，所有动态使用它的程序都将在重新启动后从更正中受益。通过静态链接包含此函数的程序必须先重新链接

动态链接缺点：

- 如果较新版本不正确，不兼容的更新库将破坏依赖于先前版本库行为的可执行文件
- 

创建动态库：

动态库文件名通常在类Unix系统上具有“.so”扩展名，在Microsoft Windows上具有“.dll”扩展名

