# C11

## æ–°åŠŸèƒ½

### Generic selection

ä½¿ç”¨_Genericå…³é”®å­—ï¼Œæ ¹æ®ç»™å®šæ§åˆ¶è¡¨è¾¾å¼çš„ç±»å‹é€‰æ‹©è¡¨è¾¾å¼ã€‚_Genericæ ¼å¼å¦‚ä¸‹ï¼š

```c
_Generic( controlling-expression, T1: E1, ... )
```

è¿™é‡Œ;

- controlling-expresionæ˜¯äº§ç”Ÿç±»å‹åˆ—è¡¨ä¸­å­˜åœ¨çš„ç±»å‹çš„è¡¨è¾¾å¼ï¼ˆT1ï¼š E1ï¼Œâ€¦ï¼‰ã€‚
- T1 æ˜¯ä¸€ä¸ªç±»å‹
- E1 æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼

å¯é€‰çš„ï¼Œåœ¨ç±»å‹åˆ—è¡¨ä¸­æŒ‡å®šé»˜è®¤å€¼å°†åŒ¹é…ä»»ä½•æ§åˆ¶è¡¨è¾¾å¼ç±»å‹

```c
#define abs(expr) _Generic((expr), \
    int: abs(expr), \
    long int: labs(expr), \
    float: fabs(expr), \
    /* ... */ \
    /* Don't call abs for unsigned types, etc. */ \
    default: expr \
)

printf("%d %li %f %d\n", abs(-123), abs(-123l), abs(-3.14f), abs(123u));
// prints: 123 123 3.14 99 123
```

## alignof

ä½¿ç”¨ `<stdalig. h>` ä¸­å®šä¹‰çš„ `_Alignof` å…³é”®å­—æˆ–æ–¹ä¾¿å®æ¥æŸ¥è¯¢ç»™å®šç±»å‹çš„å¯¹é½è¦æ±‚

```c
// On a 64-bit x86 machine:
alignof(char); // == 1
alignof(int); // == 4
alignof(int*); // == 8

// Queries alignment of array members.
alignof(int[5]); // == 4

struct foo { char a; char b; };
alignof(struct foo); // == 1

// 3 bytes of padding between `a` and `b`.
struct bar { char a; int b; };
alignof(struct bar); // == 4
```

max_align_tæ˜¯ä¸€ç§ç±»å‹ï¼Œå…¶å¯¹é½æ–¹å¼ä¸æ¯ä¸ªæ ‡é‡ç±»å‹çš„å¯¹é½æ–¹å¼ä¸€æ ·å¤§

## alignas

ä½¿ç”¨_Alignaså…³é”®å­—è®¾ç½®ç»™å®šå¯¹è±¡çš„å¯¹é½æ–¹å¼ï¼Œæˆ–åœ¨ `<stdalig. h>` ä¸­è®¾ç½®å®çš„å¯¹é½æ–¹

```c
struct sse_t
{
    // Aligns `sse_data` on a 16 byte boundary.
    alignas(16) float sse_data[4];
};

struct buffer
{
    // Align `buffer` to the same alignment boundary as an `int`.
    alignas(int) char buf[sizeof(int)];
};
```

max_align_tæ˜¯ä¸€ç§ç±»å‹ï¼Œå…¶å¯¹é½æ–¹å¼ä¸æ¯ä¸ªæ ‡é‡ç±»å‹çš„å¯¹é½æ–¹å¼ä¸€æ ·å¤§

### static_assert

ç¼–è¯‘æ—¶æ–­è¨€ï¼Œå¯ä»¥ä½¿ç”¨_Static_assertå…³é”®å­—ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨assert. hä¸­å®šä¹‰çš„static_assertå…³é”®å­—å®

```c
static_assert(sizeof(int) == sizeof(char), "`int` and `char` sizes do not match!");
```

### noreturn

æŒ‡å®šå‡½æ•°ä¸è¿”å›ã€‚å¦‚æœå‡½æ•°è¿”å›ï¼Œæ— è®ºæ˜¯é€šè¿‡è¿”å›è¿”å›è¿˜æ˜¯åˆ°è¾¾å‡½æ•°ä½“çš„æœ«å°¾ï¼Œå®ƒçš„è¡Œä¸ºéƒ½æ˜¯æœªå®šä¹‰çš„ã€‚nobackæ˜¯åœ¨ `<stdnoreinto. h>` ä¸­å®šä¹‰çš„å…³é”®å­—å®

```c
noreturn void foo()
{
    exit(0);
}
```

### Unicode literals

åˆ›å»º 16 ä½æˆ– 32 ä½ Unicode å­—ç¬¦ä¸²æ–‡å­—å’Œå­—ç¬¦å¸¸é‡

```c
char16_t c1 = u'è²“';
char32_t c2 = U'ğŸŒ';

char16_t s1[] = u"açŒ«ğŸŒ"; // => [0x0061, 0x732B, 0xD83C, 0xDF4C, 0x0000]
char32_t s2[] = U"açŒ«ğŸŒ"; // => [0x00000061, 0x0000732B, 0x0001F34C, 0x00000000]
```

## åŒ¿åç»“æ„å’Œè”åˆ

å…è®¸æœªå‘½åï¼ˆå³åŒ¿åï¼‰ç»“æ„æˆ–è”åˆã€‚åŒ¿åè”åˆçš„æ¯ä¸ªæˆå‘˜éƒ½è¢«è®¤ä¸ºæ˜¯å°é—­ç»“æ„æˆ–è”åˆçš„æˆå‘˜ï¼Œä¿æŒå¸ƒå±€ä¸å˜ã€‚å¦‚æœå°é—­ç»“æ„æˆ–è”åˆä¹Ÿæ˜¯åŒ¿åçš„ï¼Œè¿™å°†é€’å½’åº”ç”¨

```c
struct v
{
   union // anonymous union
   {
       int a;
       long b;
   };
   int c;
} v;
 
v.a = 1;
v.b = 2;
v.c = 3;

printf("%d %ld %d", v.a, v.b, v.c); // prints "2 2 3"

union v
{
   struct // anonymous struct
   {
       int a;
       long b;
   };
   int c;
} v;
 
v.a = 1;
v.b = 2;
v.c = 3;

printf("%d %ld %d", v.a, v.b, v.c); // prints "3 2 3"
```

## C 11 åº“ç‰¹æ€§

ä»¥ `_s` ç»“å°¾çš„å‡½æ•°æ›´åŠ å®‰å…¨ï¼Œå®ƒå¯ä»¥è¿›è¡Œè¾¹ç•Œæ£€æŸ¥

timespec_get, ä½¿ç”¨ç»™å®šæ—¶åŸºçš„å½“å‰æ—¶é—´å¡«å…… struct timespec å¯¹è±¡

```c
struct timespec ts;
timespec_get(&ts, TIME_UTC);
char buff[BUFFER_SIZE];
strftime(buff, sizeof(buff), "%D %T", gmtime(&ts.tv_sec));
printf("Current time: %s.%09ld UTC\n", buff, ts.tv_nsec);
```

aligned_malloc, åˆ†é…æŒ‡å®šå¯¹é½æ–¹å¼çš„å­˜å‚¨å­—èŠ‚

```c
// Allocate at a 256-byte alignment.
int* p = aligned_alloc(256, sizeof(int));
// ...
free(p);
```

char32_t, ç”¨äºä¿å­˜ 32 ä½å®½å­—ç¬¦çš„æ— ç¬¦å·æ•´æ•°ç±»å‹
char16_t, ç”¨äºä¿å­˜ 16 ä½å®½å­—ç¬¦çš„æ— ç¬¦å·æ•´æ•°ç±»å‹

`<stdatomic.h>
_Atomic ç±»å‹è¯´æ˜ç¬¦/é™å®šç¬¦ç”¨äºè¡¨ç¤ºå˜é‡æ˜¯åŸå­ç±»å‹ã€‚åŸå­ç±»å‹çš„å¤„ç†æ–¹å¼ä¸éåŸå­ç±»å‹çš„å¤„ç†æ–¹å¼ä¸åŒï¼Œå› ä¸ºè®¿é—®åŸå­ç±»å‹å¯ä»¥é¿å…æ•°æ®äº‰ç”¨

```c
_Atomic int a;
a = 1; // mov     ecx, 1
       // xchg    dword ptr [rbp - 8], ecx

int b;
b = 1; // mov     dword ptr [rbp - 8], 1
```

è¯·æ³¨æ„ï¼ŒåŸå­ç±»å‹å…ˆä½¿ç”¨ mov ç„¶åä½¿ç”¨ xchg æŒ‡ä»¤å°†å€¼ 1 èµ‹ç»™ aï¼Œè€Œ b ä½¿ç”¨å•ä¸ª movã€‚å…¶ä»–æ“ä½œå¯èƒ½åŒ…æ‹¬ +=ã€++ ç­‰......å¯¹åŸå­ç±»å‹çš„æ™®é€šè¯»å–å’Œå†™å…¥è®¿é—®æ˜¯é¡ºåºä¸€è‡´çš„

Atomic flags, åŸå­æ ‡å¿—
atomic_flag æ˜¯è¡¨ç¤ºæ ‡å¿—çš„æ— é”ï¼ˆä¿è¯ï¼‰åŸå­å¸ƒå°”ç±»å‹ã€‚ä½¿ç”¨æ ‡å¿—çš„åŸå­æ“ä½œçš„ä¸€ä¸ªç¤ºä¾‹æ˜¯ test-and-setã€‚ä½¿ç”¨ ATOMIC_FLAG_INIT å·¨é›†åˆå§‹åŒ– atomic_flag å¯¹è±¡

ä½¿ç”¨ atomic_flag ä½œä¸ºâ€œè‡ªæ—‹å€¼â€çš„ç®€å•è‡ªæ—‹é”å®ç°

```c
struct spinlock
{
    // false - lock is free, true - lock is taken
    atomic_flag flag;
};

void acquire_spinlock(struct spinlock* lock)
{
    // `atomic_flag_test_and_set` returns the value of the flag.
    // We keep spinning until the lock is free (value of the flag is `false`).
    while (atomic_flag_test_and_set(&lock->flag) == true);
}

void release_spinlock(struct spinlock* lock)
{
    atomic_flag_clear(&lock->flag);
}

void print_foo(void* lk)
{
    struct spinlock* lock = (struct spinlock*) lk;
    acquire_spinlock(lock);
    printf("foo\n");
    release_spinlock(lock);
}

void print_bar(void* lk)
{
    struct spinlock* lock = (struct spinlock*) lk;
    acquire_spinlock(lock);
    printf("bar\n");
    release_spinlock(lock);
}
```

Atomic variables, åŸå­å˜é‡
åŸå­å˜é‡æ˜¯å£°æ˜ä¸ºåŸå­ç±»å‹çš„å˜é‡ã€‚åŸå­å˜é‡æ—¨åœ¨ä¸åŸå­æ“ä½œä¸€èµ·ä½¿ç”¨ï¼ŒåŸå­æ“ä½œå¯¹è¿™äº›å˜é‡æŒæœ‰çš„å€¼è¿›è¡Œæ“ä½œï¼ˆæ ‡å¿—æ“ä½œé™¤å¤–ï¼Œå³ã€‚ä¸ atomic_flag ä¸åŒï¼Œå®ƒä»¬ä¸èƒ½ä¿è¯æ˜¯æ— é”çš„ã€‚ä½¿ç”¨ ATOMIC_VAR_INIT å·¨é›†æˆ– atomic_init åˆå§‹åŒ–åŸå­å˜é‡ï¼ˆå¦‚æœå·²é»˜è®¤æ„é€ ï¼‰

C11 Atomics åº“æä¾›äº†è®¸å¤šé¢å¤–çš„åŸå­æ“ä½œã€å†…å­˜å›´æ ï¼Œå¹¶å…è®¸ä¸ºåŸå­æ“ä½œæŒ‡å®šå†…å­˜é¡ºåº

```c
struct spinlock
{
    // false - lock is free, true - lock is taken
    atomic_bool flag;
};

void acquire_spinlock(struct spinlock* lock)
{
    bool expected = false;
    // `atomic_compare_exchange_weak` returns `false` when the value of the
    // flag is not equal to `desired`. We keep spinning until the lock is
    // free (value of the flag is `false`).
    while (atomic_compare_exchange_weak(&lock->flag, &expected, true) == false)
    {
        // `expected` will get set to the value of the flag for every call.
        // Reset it since we always "expect" `false`.
        expected = false;
    }
}

void release_spinlock(struct spinlock* lock)
{
    atomic_store(&lock->flag, false);
}

void print_foo(void* lk)
{
    struct spinlock* lock = (struct spinlock*) lk;
    acquire_spinlock(lock);
    printf("foo\n");
    release_spinlock(lock);
}

void print_bar(void* lk)
{
    struct spinlock* lock = (struct spinlock*) lk;
    acquire_spinlock(lock);
    printf("bar\n");
    release_spinlock(lock);
}

struct spinlock lock;
atomic_init(&lock.flag, false);

// In Thread A:
print_foo(&lock);
// ==============
// In Thread B:
print_bar(&lock);
```

<threads.h>, C11 æä¾›äº†ä¸€ä¸ªä¸æ“ä½œç³»ç»Ÿæ— å…³çš„çº¿ç¨‹åº“ï¼Œæ”¯æŒçº¿ç¨‹åˆ›å»ºã€äº’æ–¥é”å’Œæ¡ä»¶å˜é‡ã€‚çº¿ç¨‹åº“ä½äº <threads.h> ä¸­ã€‚æˆªè‡³ 2023 å¹´ 9 æœˆï¼Œå®ƒåœ¨å¤§å¤šæ•°ä¸»è¦ç¼–è¯‘å™¨ä¸­çš„æ”¯æŒå¾ˆå·®

https://github.com/AnthonyCalandra/modern-c-features
https://github.com/AnthonyCalandra/modern-cpp-features
