# C99

对编译器限制增加了，比如源程序每行要求至少支持到 4095 字节，变量名函数名的要求支持到 63 字节 (extern 要求支持到 31)
预处理增强了。例如：
宏支持取参数 #define Macro(...) __VA_ARGS__
使用宏的时候，参数如果不写，宏里用 #,## 这样的东西会扩展成空串。(以前会出错的)
支持 // 行注释（这个特性实际上在C89的很多编译器上已经被支持了）
增加了新关键字 restrict, inline, _Complex, _Imaginary, _Bool
支持 long long, long double _Complex, float _Complex 这样的类型
支持 <: :> <% %> %: %:%: ，等等奇怪的符号替代，D&E 里提过这个
支持了不定长的数组。数组的长度就可以用变量了。声明类型的时候呢,就用 int a[*] 这样的写法。不过考虑到效率和实现，这玩意并不是一个新类型。所以就不能用在全局里，或者 struct union 里面，如果你用了这样的东西，goto 语句就受限制了。
变量声明不必放在语句块的开头，for 语句提倡这么写 for(int i=0;i<100;++i) 就是说，int i 的声明放在里面，i 只在 for 里面有效。(VC没有遵守这条标准，i 在 for 外也有效)
当一个类似结构的东西需要临时构造的时候，可以用 (type_name){xx,xx,xx} 这有点像 C++ 的构造函数
初始化结构的时候现在可以这样写:
      struct {int a[3], b;} hehe[] =  { [0].a = {1}, [1].a = 2 };

      struct {int a, b, c, d;} hehe =  { .a = 1, .c = 3, 4, .b = 5}  // 3,4 是对 .c,.d 赋值的

字符串里面，/u 支持 unicode 的字符
支持 16 进制的浮点数的描述
所以 printf scanf 的格式化串多支持了 ll / LL (VC6 里用的 I64) 对应新的 long long 类型。
浮点数的内部数据描述支持了新标准，这个可以用 #pragma 编译器指定
除了已经有的 __line__ __file__ 以外，又支持了一个 __func__ 可以得到当前的函数名
对于非常数的表达式，也允许编译器做化简
修改了对于 / % 处理负数上的定义，比如老的标准里 -22 / 7 = -3, -22 % 7 = -1 而现在 -22 / 7 = -4, -22 % 7 = 6      
取消了不写函数返回类型默认就是 int 的规定
允许 struct 定义的最后一个数组写做 [] 不指定其长度描述
const const int i; 将被当作 const int i; 处理
增加和修改了一些标准头文件, 比如定义 bool 的 <stdbool.h> 定义一些标准长度的 int 的 <inttypes.h> 定义复数的 <complex.h> 定义宽字符的 <wctype.h> 有点泛型味道的数学函数 <tgmath.h> 跟浮点数有关的 <fenv.h>。<stdarg.h> 里多了一个 va_copy 可以复制 ... 的参数。<time.h> 里多了个 struct tmx 对 struct tm 做了扩展
输入输出对宽字符还有长整数等做了相应的支持
