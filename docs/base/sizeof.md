# sizeof

## 综述

在C和C+编程语言中，一元运算符sizeof生成变量或数据类型的大小，以类型所需的char大小的存储单元的数量衡量。因此，结构sizeof(Char)保证为1。char类型的实际位数由标准include file limits.h.中定义的预处理器宏CHAR_BIT指定。在大多数现代系统中，这是8位。sizeof的结果具有一个无符号整数类型，通常由size_t表示

运算符有一个操作数，它是变量或数据类型转换。转换是括在括号中的数据类型。数据类型不仅可以是基本类型(如整数和浮点类型)，也可以是指针类型和复合数据类型(联合、结构和C+类)。

## Need

许多程序必须知道特定数据类型的存储大小。尽管对于C或C+的任何给定实现，特定数据类型的大小是恒定的，但对于不同的实现平台，C和C+中甚至基元类型的大小可能定义不同。例如，数组空间的运行时分配可以使用以下代码，其中sizeof运算符应用于类型int的强制转换：

`int *pointer =  malloc(10 * sizeof (int));`

在本例中，函数malloc分配内存并返回指向内存块的指针。分配的块大小等于int类型的单个对象的字节数乘以10，为十个整数提供空间。

假设任何数据类型的大小通常是不安全的。例如，尽管32位系统上的C和C+的大多数实现将类型int定义为四个八位字节，但当代码被移植到不同的系统时，该大小可能会改变，从而破坏代码。这方面的例外是数据类型char，在任何符合标准的C实现中，其大小始终为1。此外，由于填充，经常很难预测复合数据类型(如结构或联合)的大小。sizeof的使用增强了可读性，因为它避免了未命名的数字常量(幻数)。

假设任何数据类型的大小通常是不安全的。例如，尽管32位系统上的C和C+的大多数实现将类型int定义为四个八位字节，但当代码被移植到不同的系统时，该大小可能会改变，从而破坏代码。这方面的例外是数据类型char，
在任何符合标准的C实现中，其大小始终为1。此外，由于填充，经常很难预测复合数据类型(如结构或联合)的大小。sizeof的使用增强了可读性，因为它避免了未命名的数字常量(幻数)。

分配相同数组空间的等效语法来自于使用指向存储地址的指针的解除引用形式，这次将运算符应用于指针变量：

`int *pointer =  malloc(10 * sizeof *pointer);`

## 使用

sizeof运算符计算其操作数所需的内存存储空间。操作数在关键字sizeof之后写入，并且可以是存储空间的符号，例如变量、类型名称或表达式。如果是类型名称，则必须将其括在括号中。运算的结果是操作数的大小(以字节为单位)，或内存表示的大小。对于表达式，其计算结果为表达式求值将导致的类型的表示大小，而这不是执行的。

例如，由于sizeof(Char)被定义为1，并且假设整数类型为四字节长，因此将打印以下代码


某些标准头文件，如stddef.h，定义size_t来表示sizeof表达式结果的无符号整数类型。printf width说明符z旨在格式化该类型。

sizeof不能在C预处理器表达式(如#if)中使用，因为预处理器没有数据类型。

## 应用于数组

当sizeof应用于数组的名称时，结果是存储整个数组所需的字节数。这是数组名称转换为指向数组的第一个元素的指针的规则的少数例外之一，并且可能只是因为实际数组大小在编译时是固定的和已知的，
当计算sizeof运算符时。以下程序使用sizeof确定声明数组的大小，避免在复制字符时发生缓冲区溢出：

这里，sizeof buffer等同于10*sizeof buffer[0]，其计算结果为10，因为char类型的大小定义为1。
C99为结构添加了对灵活数组成员的支持。
这种形式的数组声明只允许作为结构中的最后一个元素，并且与普通数组的不同之处在于没有为编译器指定长度。
对于名为s的结构，其中包含名为a的灵活数组成员，sizeof s因此等同于offsetof(s，a)：
