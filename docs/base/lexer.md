# 词法约定

C++ 程序的基本元素。 你将使用这些名为“词法元素”或“标记”的元素构造用于构造完整程序的语句、定义和声明等

C++ 程序的文本由标记和空格组成。 标记是对编译器有用的 C++ 程序的最小元素。 C++ 分析器识别这些类型的标记：

- 关键字
- 标识符
- 数值、布尔和指针文本
- 字符串和字符文本
- 用户定义的文本
- 运算符
- 标点符号

标记通常由一个或多个空格分隔：

- 空白 (空格、制表符、换行符)
- 水平或垂直制表符 (\t \v)
- 新行 (\n)
- 表单源
- 注释 (// 或 /* */)

源码字符集 ： utf-8
执行字符集 ： utf-8

## 关键字

关键字是具有特殊意义的预定义保留标识符。 它们不能用作程序中的标识符。 Microsoft C++ 保留了下列关键字。 带有前导下划线的名称，以及为 C++/CX 和 C++/CLI 指定的名称都是 Microsoft 扩展

## 标识符

- 标识符是用于表示以下内容之一的字符序列：
- 对象或变量名称
- 类、结构或联合名称
- 枚举类型名称
- 类、结构、联合或枚举的成员
- 函数或类成员函数
- typedef 名称
- 标签名称
- 宏名称
- 宏参数

允许将以下字符用作标识符**开头**的任意字符：

> _ a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

允许将以下字符用作标识符中除第一个字符以外的任意字符

> 0 1 2 3 4 5 6 7 8 9

标识符的第一个字符必须是字母字符（大写、小写或带下划线 ( _ ) 的字母）。 由于 C++ 标识符区分大小写，因此 fileName 与 FileName不同
标识符不能与关键字有完全相同的拼写和大小写。 包含关键字的标识符是合法的。 例如， Pint 是一个合法标识符，即使它包含 int关键字

## 注释

注释是编译器忽略的文本，但它对程序员很有用。 注释通常用于批注代码以供将来参考。 编译器将它们视为空白。 可以在测试中使用注释来使某些代码行处于非活动状态；但是，`#if/#endif` 预处理器指令在这方面表现更佳，因为你可以环绕包含注释的代码，但不能嵌套注释

## 标点符号

在 C++ 中，标点符号相对于编译器来说具有语法意义和语义含义，但是它们本身不会指定一个产生数值的操作。 某些标点符号（单独或组合）也可以是 C++ 运算符或对预处理器很重要

以下任意字符都被视为标点符号：

> ! % ^ & * ( ) - + = { } | ~ [ ] \ ; ' : " < > ? , . / #
标点符号 [ ]、( ) 和 { } 必须成对出现

## 数值、布尔和指针文本

整数文本:

整数文本以数字开头，没有小数部分或指数。 你可以指定十进制、二进制、八进制或十六进制形式的整数文本。 可以选择使用后缀将整数文本指定为无符号类型以及 long 类型或 long long 类型。

如果没有前缀或后缀，编译器将为整型文本值赋予 int 类型（32 位），前提是该值符合该类型，否则将赋予 long long 类型（64 位）

要指定十进制整型文本，请以非零数字作为规范的开头

```cpp
int i = 157;        // Decimal literal
int j = 0198;       // Not a decimal number; erroneous octal literal
int k = 0365;       // Leading zero specifies octal literal, not decimal
int m = 36'000'000  // digit separators make large values more readable
```

要指定八进制整型文本，请以 0 作为规范的开头，后跟 0 到 7 之间的一系列数字。 在指定八进制文本时，使用数字 8 和 9 是错误做法

```cpp
int i = 0377;   // Octal literal
int j = 0397;   // Error: 9 is not an octal digit
```

要指定十六进制整型文本，请以 0x 或 0X 作为规范的开头（“x”的大小写形式并不重要），后跟 0 到 9 以及 a（或 A）到 f（或 F）之间的一系列数字。 十六进制数字 a（或 A）到 f（或 F）表示介于 10 和 15 之间的值

```cpp
int i = 0x3fff;   // Hexadecimal literal
int j = 0X3FFF;   // Equal to i
```

若要指定无符号类型，请使用 u 或 U 后缀。 若要指定 long 类型，请使用 l 或 L 后缀。 要指定 64 位整型类型，请使用 LL 或 ll 后缀。 i64 后缀仍受支持，但不建议使用。 它是 Microsoft 专用的，不可移植。 例如：

```cpp
unsigned val_1 = 328u;                  // Unsigned value
long val_2 = 0x7FFFFFL;                 // Long value specified
                                        //  as hex literal
unsigned long val_3 = 0776745ul;        // Unsigned long value
auto val_4 = 108LL;                           // signed long long
auto val_4 = 0x8000000000000000ULL << 16;     // unsigned long long
```

数字分隔符：可以使用单引号字符（撇号）分隔较大数字中的位值，使它们更易于人类阅读。 分隔符不会对编译产生任何影响

```cpp
long long i = 24'847'458'121;
```

浮点文本:

浮点文本指定必须具有小数部分的值。 这些值包含小数点 (.) 并可能包含指数。

浮点文本有一个有效数字（有时称为尾数），它指定数字的值。 它们有一个指数，用于指定数字的度量值。 而且，它们有一个可选的后缀，用于指定文本的类型。 指定的有效数字的格式是一系列位数后跟一个句点，再后跟表示数字的小数部分的可选的一系列位数。 例如：

```cpp
18.46
38.
```

浮点文本的指数部分由字母 e 或 E 后跟一个可选的符号和一个十进制整数组成。 例如：

```cpp
18.46e-3
18.46e+3

```

浮点文本默认为 double 类型。 通过使用后缀 f 或 l 或 F 或 L（后缀不区分大小写），可以将文本指定为 float 或 long double。
虽然 long double 和 double 具有相同的表示形式，但它们不属于同一类型。 例如，你可能有类似于下面的重载函数

```cpp
void func(long double);
void func(double);
```

布尔值文字:

布尔文本为 true 和 false

指针文本:

C++ 引入了 nullptr 文本来指定初始化为零的指针。 在可移植代码中，应使用 nullptr，而不是整型类型零或宏（如 NULL

二进制文本：

可以通过使用 0B 或 0b 前缀，后跟一系列 1 和 0，来指定二进制文本：

```cpp
int i = 0B10101010;   // Binary literal
int j = 0b10101010;   // Equal to i
```

避免将文本用作“魔术常量”, 你可以在表达式和语句中直接使用文本，虽然这种编程做法并不一定好用：

在上一个示例中，更好的做法是使用能够传达明确含义的命名常量，例如“MAXIMUM_ERROR_THRESHOLD”。 如果最终用户看到返回值“成功”，那么使用命名字符串常量可能会更好。 可以将字符串常量保存在可本地化为其他语言的文件中的单个位置。 使用命名常量可帮助你自己和其他人了解代码的含义。

字符串文本：

C++ 支持各种字符串和字符类型，并提供表示每种类型的文本值的方法。 在源代码中，使用字符集表示字符和字符串文本的内容。 通用字符名称和转义字符允许你仅使用基本源字符集表示任何字符串。 原始字符串使你可以避免使用转义字符，可以用于表示所有类型的字符串。 还可以创建 std::string 文本，而无需执行额外的构造或转换步骤

字符串文本可以没有前缀，也可以具有 u8、L、 u和 U 前缀以分别指示窄字符（单字节或多字节）、UTF-8、宽字符（UCS-2 或 UTF-16）、UTF-16 和 UTF-32 编码。 原始字符串文本可以具有 R、u8R、LR、uR 和 UR 前缀来表示这些编码的原始版本等效项。 若要创建临时或静态 std::string 值，可以使用带 s 后缀的字符串文本或原始字符串文本。 有关详细信息，请参阅下面的字符串文本部分。 有关基本源字符集、通用字符名称以及在源代码中使用扩展代码页中的字符的详细信息，请参阅字符集

编码
字符文本根据其前缀以不同的方式进行编码。

没有前缀的字符文本是普通字符文本。 包含可在执行字符集中表示的单个字符、转义序列或通用字符名称的普通字符文本的值等于它在执行字符集中的编码数值。 包含多个字符、转义序列或通用字符名称的普通字符文本是多字符文本。 无法在执行字符集中表示的多字符文本或普通字符文本的类型为 int，其值由实现定义。 有关 MSVC，请参阅下面的 特定于 Microsoft 部分。

以 L 前缀开头的字符文本是宽字符文本。 包含单个字符、转义序列或通用字符名称的宽字符文本的值等于它在执行宽字符集中的编码数值，除非该字符文本在执行宽字符集中没有表示形式，在这种情况下，值由实现定义。 包含多个字符、转义序列或通用字符名称的宽字符文本的值由实现定义。 有关 MSVC，请参阅下面的 特定于 Microsoft 部分。

以 u8 前缀开头的字符文本是 UTF-8 字符文本。 如果包含单个字符、转义序列或通用字符名称的 UTF-8 字符文本的值可以由单个 UTF-8 代码单元（对应于 C0 控件和基本拉丁语 Unicode 块）表示，该值等于其 ISO 10646 码位值。 如果该值不能由单个 UTF-8 代码单元表示，则程序的格式不当。 包含多个字符、转义序列或通用字符名称的 UTF-8 字符文本是格式不当的。

以 u 前缀开头的字符文本是 UTF-16 字符文本。 如果包含单个字符、转义序列或通用字符名称的 UTF-16 字符文本的值可以由单个 UTF-16 代码单元（对应于基本多语言平面）表示，该值等于其 ISO 10646 码位值。 如果该值不能由单个 UTF-16 代码单元表示，则程序的格式不当。 包含多个字符、转义序列或通用字符名称的 UTF-16 字符文本是格式不当的。

以 U 前缀开头的字符文本是 UTF-32 字符文本。 包含单个字符、转义序列或通用字符名称的 UTF-32 字符文本的值等于其 ISO 10646 码位值。 包含多个字符、转义序列或通用字符名称的 UTF-32 字符文本是格式不当的。

字符串文本是用双引号括起来的字符序列。 字符串文本中的字符是字符串的一部分。 字符串文本中的转义序列会导致编译器将转义序列替换为实际字符。 转义序列以反斜杠字符（\）开头。 转义序列可以是以下之一：

转义序列

| 转义序列 | 含义 |
| --- | --- |
| \a | 警报 |
换行符	\n
反斜杠	\\
水平制表符	\t
问号	？ 或 \？
垂直制表符	\v
单引号	%>
退格符	\b
双引号	%>
回车符	\r
null 字符	\0
换页符	\f
八进制	\ooo
警报（响铃）	\a
十六进制	\xhhh

八进制转义序列包含一个反斜杠，后跟 1 到 3 个八进制数字的序列。 如果在第三位数之前遇到八进制转义序列，该转义序列将在第一个不是八进制数字的字符处终止。 可能的最高八进制值为 \377

十六进制转义序列包含一个反斜杠，后接 x 字符，再后接由一个或多个十六进制数字组成的序列。 将忽略前导零。 在普通或以 u8 为前缀的字符文本中，最高十六进制值为 0xFF。 在使用 L 或 u 前缀的宽字符文本中，最大的十六进制值为 0xFFFF。 在使用 U 前缀的宽字符文本中，最大的十六进制值为 0xFFFFFFFF

反斜杠字符 (\) 在位于行末尾时将作为行继续符。 如果你希望反斜杠字符显示为字符文本，则必须在一行中键入两个反斜杠 (\\)。 有关行继续符的详细信息，请参阅 Phases of Translation

