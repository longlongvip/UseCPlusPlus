# 基本概念

## C++ 类型系统

在 C++ 中，类型的概念非常重要。 每个变量、函数自变量和函数返回值必须具有一个类型以进行编译。 此外，在计算表达式前，编译器会隐式给出每个表达式（包括文本值）的类型。 类型的一些示例包括内置类型，例如用于存储整数值的 int，用于存储浮点值的 double，或用于存储文本的标准库类型，如类 std::basic_string。 可以通过定义 class 或 struct 创建自己的类型。 该类型指定为变量（或表达式结果）分配的内存量。 该类型还指定可存储的值类型、编译器如何解释这些值中的位模式以及可以对它们执行的操作

标准类型：整型、浮点值、枚举类型成员、指针类型、指针到成员类型以及 std::nullptr_t
复合类型：数组类型、函数类型、类、结构体、联合体、枚举、引用和指向非静态类成员的指针
变量：数据量的符号名称
对象：类或结构体的任何实例
纯旧数据(POD)：
void 类型：
const 类型限定符：任何内置或用户定义的类型都可由 const 关键字限定。 此外，成员函数可受到 const 限定，甚至可重载 const。 const 类型的值在初始化后将无法修改
字符串类型：
指针类型：

## 范围

- 全局范围：全局名称是在任何类、函数或命名空间之外声明的名称。 但是，在 C++ 中，即使是这些名称也具有隐式全局命名空间。 全局名称的范围从声明点扩展到声明文件末尾。 对于全局名称，可见性也受链接规则的约束，这些规则确定名称是否在程序中的其他文件中可见
- 命名空间范围：在命名空间中声明的名称（在任何类或枚举定义或函数块之外）从其声明点到命名空间末尾可见。 命名空间可以在跨不同文件的多个块中定义
- 局部范围：在函数或 lambda 中声明的名称（包括参数名称）具有局部范围
- 类范围：类成员的名称具有类范围，该范围在整个类定义中扩展，与声明点无关。 类成员可访问性由 public、private 和 protected 关键字进一步控制。 只能使用成员选择运算符（. 或 ->）或指向成员的指针运算符（.* or ->*）访问公共或受保护成员
- 语句范围：在for、if、while 或 switch 语句中声明的名称在语句块结束之前可见
- 函数范围：标签具有函数范围，这意味着它在整个函数正文中甚至在声明点之前都是可见的。 函数范围允许在声明 cleanup 标签之前编写 goto cleanup 等语句

## 头文件

必须在使用变量、函数、类等程序元素的名称之前对其进行声明。 例如，不能在没有声明“x”之前编写 x = 42

声明告知编译器，元素是 int、double、函数、class 还是其他内容
必须在使用每个名称时所在的每个 .cpp 文件中（直接或间接）声明每个名称
编译程序时，每个 .cpp 文件都会独立编译为一个编译单元
编译器不知道在其他编译单元中声明了哪些名称
如果你定义类、函数或全局变量，则必须在使用它的每个附加 .cpp 文件中提供对它的声明
在所有文件中，对它的每个声明必须完全相同。 当链接器尝试将所有编译单元合并成单个程序时，出现轻微的不一致会导致错误或意外行为

为了最大程度地减少出错的可能性，C++ 采用了使用头文件来包含声明的约定。 在一个头文件中进行声明，然后在每个 .cpp 文件或其他需要该声明的头文件中使用 #include 指令。 #include 指令在编译之前将头文件的副本直接插入 .cpp 文件中

引号用于源文件所在目录中的头文件，尖括号用于标准库标头。 此外，许多标准库标头没有 .h 或任何其他文件扩展名

不要在头文件中放置 using 语句

通常，头文件有一个 include 防范或 #pragma once 指令，用于确保它们不会多次插入到单个 .cpp 文件中

编译器完成将每个 .cpp 文件编译为 .obj 文件的操作后，会将 .obj 文件传递给链接器。 链接器合并对象文件时，会发现 my_class 的一个定义；它位于为 my_class.cpp 生成的 .obj 文件中，生成成功。

由于一个头文件可能会被多个文件执行 include 操作，因此它不能包含可能生成多个同名定义的定义。 不允许以下操作，否则会被视为非常糟糕的做法：

- 命名空间或全局范围内的内置类型定义
- 非内联函数定义
- 非常量变量定义
- 结构体、联合体定义
- using 指令

## 翻译单元和链接

在 C++ 程序中，符号（例如变量或函数名称）可以在其范围内进行任意次数的声明。 但是，一个符号只能被定义一次，这就是“单一定义规则”(ODR)

声明在程序中引入（或重新引入）一个名称，以及足够的信息，以便以后将该名称与定义联系起来。 定义引入一个名称，并提供创建它所需的全部信息。 如果名称表示变量，则定义会显式创建存储并进行初始化。 函数定义由签名和函数体组成。 类定义由类名和一个列出所有类成员的块组成。 （成员函数体可以选择在另一个文件中单独定义。

一个程序包括一个或多个翻译单元。 一个翻译单元由一个实现文件及其直接或间接包含的所有标头组成。 实现文件通常具有文件扩展名 .cpp 或 .cxx。 头文件通常具有扩展名 .h 或 .hpp。 每个翻译单元由编译器独立编译。 编译完成后，链接器会将编译后的翻译单元合并到单个程序中。 ODR 规则的冲突通常显示为链接器错误。 在多个翻译单元中定义同一名称时，将发生链接器错误

通常，使变量在多个文件中可见的最佳方式是在头文件中声明它。 然后，在需要声明的每个 .cpp 文件中添加一个 #include 指令。 通过在标头内容周围添加 include 防范，可以确保标头声明的名称对每个翻译单元只声明一次。 仅在一个实现文件中定义名称

在某些情况下，可能需要在 .cpp 文件中声明全局变量或类。 在这些情况下，你需要一种方法来告知编译器和链接器名称所具有的链接类型。 链接的类型指定对象的名称是仅在一个文件中可见，还是在所有文件中可见。 链接的概念仅适用于全局名称。 链接的概念不适用于在一定范围内声明的名称。 范围是由一组封闭的大括号指定的，例如在函数或类的定义中。

外部链接与内部链接：

Free 函数是在全局范围或命名空间范围内定义的函数。 默认情况下，非常量全局变量和 Free 函数具有外部链接；它们在程序中的任何翻译单元内可见。 其他任何全局对象都不能具有该名称。 具有内部链接或无链接的符号仅在声明它的翻译单元内可见。 当一个名称具有内部链接时，同一名称可能存在于另一个翻译单元中。 类定义或函数体中声明的变量没有链接。

如果要强制一个全局名称具有内部链接，可以将它显式声明为 static。 此关键字将它的可见性限制在声明它的同一翻译单元内。 在此上下文中，static 表示与应用于局部变量时不同的内容

默认情况下，以下对象具有内部链接：

const对象
constexpr对象
typedef对象
命名空间范围中的 static 对象
若要为 const 对象提供外部链接，请将其声明为 extern 并为其赋值：

extern const int x = 42; // 外部链接的 const 对象

## main 函数和命令行参数

所有 C++ 程序都必须具有 main 函数。 如果尝试在没有 main 函数的情况下编译 C++ 程序，编译器将引发错误。 （动态链接库和 static 库没有 main 函数。）main 函数是源代码开始执行的位置，但在程序进入 main 函数之前，没有显式初始值设定项的所有 static 类成员都设为零。 在 Microsoft C++ 中，全局 static 对象在进入 main 前也进行初始化。 一些限制适用于 main 函数，而不适用于任何其他 C++ 函数。 main 函数：

无法重载（请参阅函数重载）。
无法声明为 inline。
无法声明为 static。
无法提取其地址。
无法从程序调用。

main 函数没有声明，因为它内置于语言中。 如果有，则 main 的声明语法如下所示：

```cpp
int main();
int main(int argc, char *argv[]);
```

如果 main 中未指定返回值，编译器会提供零作为返回值

main 的参数可进行方便的命令行分析。 argc 和 argv 的类型由语言定义。 名称 argc 和 argv 是传统名称，但你可以按自己的意愿命名。

自变量定义如下所示：

argc
包含 argv 后面的参数计数的整数。 argc 参数始终大于或等于 1。

argv
表示由杂注用户输入的命令行自变量的以 null 结尾的字符串的数组。 按照约定，argv[0] 是用于调用程序的命令。 argv[1] 是第一个命令行参数。 命令行的最后一个参数是 argv[argc - 1]，并且 argv[argc] 始终为 NULL。

> 按照约定，argv[0] 是程序的文件名。 但在 Windows 上，可以使用 CreateProcess 来生成进程。 如果同时使用了第一个和第二个参数（lpApplicationName 和 lpCommandLine），则 argv[0] 可能不是可执行名称。 可使用 GetModuleFileName 来检索可执行名称及其完全限定的路径

## 程序终止

在 C++ 中，可以通过以下方式退出程序：

- 调用 exit 函数
- 调用 abort 函数
- 从 main 执行 return 语句

<stdlib.h> 中声明的 exit 函数将终止 C++ 程序。 作为 exit 的自变量提供的值将作为程序的返回代码或退出代码返回到操作系统。 按照约定，返回代码为零表示该程序已成功完成。 可以使用同样在 <stdlib.h> 中定义的常量 EXIT_FAILURE 和 EXIT_SUCCESS 来指示程序是成功还是失败

同样在标准包含文件 <stdlib.h> 中声明的 abort 函数用于终止 C++ 程序。 exit 与 abort 之间的差异在于，exit 允许执行 C++ 运行时终止处理（调用全局对象析构函数）。 abort 可立即终止程序。 abort 函数绕过初始化的全局静态对象的一般析构过程。 它还绕过使用 atexit 函数指定的任何特殊处理

使用 atexit 函数指定在程序终止之前执行的操作。 在执行退出处理函数之前，不会销毁在调用 atexit 之前初始化的任何全局静态对象

使用 return 语句可以从 main 指定一个返回值。 main 中 return 语句的行为首先类似于任何其他 return 语句。 任何自动变量都将被销毁。 然后，main 以返回值作为参数调用 exit。 请考虑以下示例

```cpp
// return_statement.cpp
#include <stdlib.h>
struct S 
{
    int value;
};
int main()
{
    S s{ 3 };

    exit( 3 );
    // or
    return 3;
}
```

前面示例中的 exit 和 return 语句具有类似的行为。 两者都会终止程序并向操作系统返回值 3。 不同之处在于，exit 不会销毁自动变量 s，而 return 语句会销毁。

通常，C++ 需要具有 void 之外的返回类型的函数返回一个值。 main 函数是一个异常；它可以在没有 return 语句的情况下结束。 在这种情况下，它会将特定于实现的值返回到调用过程。 （默认情况下，MSVC 返回 0。）

直接调用 exit 时（或在 main 的 return 语句之后调用它时），将销毁与当前线程关联的线程对象。 然后，按与初始化相反的顺序销毁静态对象（在调用指定给 atexit 的函数（如果有）之后）。 以下示例演示如何进行此类初始化和清理工作

在下面的示例中，在进入 main 之前，将创建和初始化静态对象 sd1 和 sd2。 使用 return 语句终止此程序后，首先销毁 sd2，然后销毁 sd1。 ShowData 类的析构函数将关闭与这些静态对象关联的文件。

```cpp
// using_exit_or_return1.cpp
#include <stdio.h>
class ShowData {
public:
   // Constructor opens a file.
   ShowData( const char *szDev ) {
   errno_t err;
      err = fopen_s(&OutputDev, szDev, "w" );
   }

   // Destructor closes the file.
   ~ShowData() { fclose( OutputDev ); }

   // Disp function shows a string on the output device.
   void Disp( char *szData ) {
      fputs( szData, OutputDev );
   }
private:
   FILE *OutputDev;
};

//  Define a static object of type ShowData. The output device
//   selected is "CON" -- the standard output device.
ShowData sd1 = "CON";

//  Define another static object of type ShowData. The output
//   is directed to a file called "HELLO.DAT"
ShowData sd2 = "hello.dat";

int main() {
   sd1.Disp( "hello to default device\n" );
   sd2.Disp( "hello to file hello.dat\n" );
}
```

## 左值和右值

## 临时对象

临时对象是由编译器创建的未命名对象，用于存储临时值

在某些情况下，编译器需要创建临时对象。 可能会出于下列原因创建这些临时对象：

- 使用一个类型不同于所初始化引用的基础类型的初始化表达式来初始化 const 引用
- 存储返回用户定义类型 (UDT) 的函数的返回值。 仅当程序未将返回值复制到对象时，才会创建这些临时对象。 例如

- 由于未将返回值复制到另一个对象，因此创建了临时对象。 创建临时内存更常见的情况是在计算必须调用重载运算符函数的表达式时。 这些重载的运算符函数将返回用户定义类型，该类型通常不会复制到另一个对象。

请考虑表达式 ComplexResult = Complex1 + Complex2 + Complex3。 将计算表达式 Complex1 + Complex2，并且结果将存储在临时对象中。 接下来，计算表达式 temporary + Complex3，并将结果复制到 ComplexResult（假设未重载赋值运算符）。

存储强制转换为用户定义的类型的结果。 在给定类型的对象显式转换为用户定义的类型时，将构造一个新对象作为临时对象。

临时对象具有根据其创建点和销毁点定义的生存期。 任何创建多个临时对象的表达式最终都会按与这些对象的创建顺序相反的顺序来销毁它们。

临时销毁发生的时间取决于它的使用方式：

- 用于初始化 const 引用的临时对象：
如果初始化表达式不是与正在初始化的引用类型相同的左值，则会创建基础对象类型的临时值。 初始化表达式会对其进行初始化。 此临时对象将在其绑定到的引用对象销毁后立即销毁。 由于此销毁很可能在创建临时表达式之后发生，因此有时称为生存期扩展。
- 作为表达式计算结果创建的临时对象：
所有不属于第一类的临时对象，以及作为表达式计算结果而创建的所有临时对象，都在表达式语句的末尾（即分号处）或用于 for、if、while、do 和 switch 语句的控制表达式的末尾销毁

## 类型转换与类型安全

## 标准转换

- 整数提升：整型类型的对象可以转换为另一个更宽的整型类型，即，可表示更大的一组值的类型
值保留提升和保留符号的提升通常会生成相同的结果。 但是，如果提升的对象显示如下，它们可能生成不同的结果：

/、%、/=、%=、<、<=、> 或 >= 的操作数

这些运算符依赖于用于确定结果的符号。 当值保留和符号保留提升应用于这些操作数时，它们将生成不同的结果。

>> 或 >>= 的左操作数

这些运算符在移位运算中会区别对待有符号的数量和无符号的数量。 对于有符号的数量，右移位运算会将符号位传播到空位位置，而空位位置则以无符号数量填充零。

重载函数的参数，或重载运算符的操作数（取决于该操作数类型用于参数匹配的符号）。 有关定义重载运算符的详细信息，请参阅重载运算符

整型转换：整型转换是整型类型之间的转换。 整型类型为 char、short（或 short int）、int、long 和 long long。 这些类型可使用 signed 或 unsigned 进行限定，unsigned 可以用作 unsigned int 的简写

有符号转无符号
有符号整数类型的对象可以转换为对应的无符号类型。 当发生这些转换时，实际位模式不会改变。 但是，对数据的解释会更改。 考虑此代码：

```cpp
int i = -1;
unsigned int j = i;
```

无符号转换为有符号
无符号整数类型的对象可以转换为对应的有符号类型。 但是，如果无符号值超出有符号类型的可表示范围，则结果将没有正确的值，如以下示例所示

```cpp
#include <iostream>

using namespace std;
int main()
{
short  i;
unsigned short u = 65533;

cout << (i = u) << "\n";
}
//Output: -3
```

浮点转换:浮动类型的对象可以安全地转换为更精确的浮点类型，也就是说，转换不会导致基数丢失。 例如，从 float 到 double 或从 double 到 long double 的转换是安全的，并且值保持不变

如果浮点类型的对象位于低精度类型可表示的范围中，则还可转换为该类型。 （请参阅浮点限制，了解浮点类型的范围。）如果原始值无法精确表示，则可以将其转换为下一个更高或更低的可表示值。 如果此类值不存在，则结果不确定。 请考虑以下示例：

```cpp
cout << (float)1E300 << endl;
```

类型 float 可表示的最大值为 3.402823466E38，这比 1E300 小很多。 因此，该数字将转换为无穷大，结果为“inf”。

整型和浮点型之间的转换：某些表达式可能导致浮点型的对象转换为整型，反之亦然。 当整型类型的对象转换为浮点类型且无法精确表示原始值时，结果要么是下一个较大的可表示值，要么是下一个较小的可表示值。

当浮点类型的对象转换为整型类型时，小数部分将被截断，或四舍五入至零。 比如数字 1.3 将转换为 1，-1.3 将转换为 -1。 如果截断的值高于最高可表示值或低于最低可表示值，则结果不确定

满足的条件	转换
其中一个操作数是 long double 类型。	另一个操作数将转换为 long double 类型。
未满足上述条件，并且其中一个操作数是 double 类型。	另一个操作数将转换为 double 类型。
未满足上述条件，并且其中一个操作数是 float 类型。	另一个操作数将转换为 float 类型。
未满足上述条件（没有任何一个操作数属于浮动类型）。	操作数获得整型提升，如下所示：

- 如果其中一个操作数的类型为 unsigned long，则另一个操作数被转换为 unsigned long 类型。
- 如果未满足上述条件，并且其中一个操作数是 long 类型，另一个操作数是 unsigned int 类型，则这两个操作数都将转换为 unsigned long 类型。
- 如果未满足上述两个条件，并且其中一个操作数是 long 类型，则另一个操作数将转换为 long 类型。
- 如果未满足上述三个条件，并且其中一个操作数是 unsigned int 类型，则另一个操作数将转换为 unsigned int 类型。
- 如果上述条件均未满足，则两个操作数都将转换为 int 类型。

指针转换：在赋值、初始化、比较和其他表达式中，可以转换指针
指向类的指针：
指向函数的指针：如果类型 void * 足以保留指向函数的指针，则该指针可以转换为 void * 类型
指向 void 的指针： 指向 void 类型的指针可以转换为指向其他任何类型的指针，但仅适合于显式类型转换（与在 C 中的情况不同）。 指向任何类型的指针可以隐式转换为指向 void 类型的指针。 指向类型的不完整对象的指针可以转换为指向 void（隐式）和 back（显式）的指针。 此类转换的结果与原始指针的值相等。 对象被视为是不完整的（如果已声明对象），但未提供足够多的可用信息，无法确定其大小或基类。

指向不是 const 或 volatile 的任何对象的指针可以隐式转换为 void * 类型的指针

固定和可变指针：C++ 不会应用从 const 或 volatile 类型到不是 const 或 volatile 类型的标准转换。 但是，任何类型的转换都可以用显式类型强制转换指定（包括不安全的转换）
null 指针转换：计算结果为零的整型常量表达式，或到某个指针类型的此类表达式强制转换，将转换为称为“空指针”的指针。 此指针与指向任何有效对象或函数的指针相比总是不相等的。 一个例外是指向基于对象的指针，它们可以具有相同的偏移量，但仍然指向不同的对象。在 C++11 中，nullptr 类型应优先于 C 样式空指针
指针表达式转换：带数组类型的所有表达式都可以转换为同一类型的指针。 转换的结果是指向第一个数组元素的指针。 下面的示例演示了这样的转换：

```cpp
char szPath[_MAX_PATH]; // Array of type char.
char *pszPath = szPath; // Equals &szPath[0].
```

生成返回特定类型的函数的表达式将转换为指向返回该类型的函数的指针，以下情况除外：

- 表达式用作 address-of 运算符 (&) 的操作数
- 表达式用作到 function-call 运算符的操作数

引用转换：对类的引用可在以下情况下转换为对基类的引用：

- 指定的基类是可访问的
- 转换是明确的
- 转换的结果为指向表示基类的子对象的指针
