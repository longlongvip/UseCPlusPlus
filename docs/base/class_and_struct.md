# 类和结构体

类和结构在 C++ 中是相同的，只不过在结构中，默认可访问性是公共的，而在类中，默认值是私有的

类和结构是用于定义你自己的类型的构造。 类和结构都可以包含数据成员和成员函数，使你可以描述类型的状态和行为

三种类类型是结构、类和联合。 它们使用 struct、class 和 union 关键字进行声明。 下表显示三种类类型之间的差异：

| 类类型 | 结构类型 | 联合类型 |
| ------ | -------- | -------- |
| `class` | `struct` | `union` |
| 默认访问是私有的 | 默认访问是公共的 | 默认访问是公共的 |
| 没有使用约束 | 没有使用约束 | 一次只使用一个成员 |

## 结构体

在 C 中，必须显式使用 `struct` 关键字来声明结构。 在 C++ 中，不需要在定义该类型之后使用 `struct` 关键字

可以选择在定义结构类型时，通过在右大括号和分号之间放置一个或多个逗号分隔的变量名称来声明变量

可以初始化结构变量。 每个变量的初始化**必须**括在大括号中

## 类成员

- 可变和静态数据成员包括内置类型和其他用户定义的类型
- 成员函数
- 特殊成员函数
- 运算符
- 嵌套类、枚举和联合
- 位域
- 友元
- 别名和 typedef

## 成员的可访问性

通过访问控制，可以将类的 public 接口与 private 实现详细信息和仅供派生类使用的 protected 成员分离开来

访问说明符应用于在它之后声明的所有成员，直到遇到下一个访问说明符

默认访问是类中的 private，以及结构或联合中的 public

类中的访问说明符可按任何顺序使用任意次数

类类型的对象的存储分配是依赖于实现的。 但是，编译器必须保证在访问说明符之间将成员分配到更高的连续内存地址

| 访问类型 | 含义 |
| -------- | ---- |
| `public` | 声明为 `public` 的类成员可由任意函数使用 |
| `private` | 声明为 `private` 的类成员只能由类的成员函数和友元（类或函数）使用 |
| `protected` | 声明为 `protected` 的类成员可由类的成员函数和友元（类或函数）使用， 此外，它们还可由派生自该类的类使用 |

需要注意的是：访问控制有助于阻止通过不适当的方式使用对象。 在执行显式类型转换（强制转换）时，此保护将丢失

两个因素控制基类的哪些成员可在派生类中访问：

- 派生类是否使用 `public` 访问说明符声明基类
- 基类中对成员的访问权限如何

下表显示了这些因素之间的交互以及如何确定基类成员访问:

| `private` | `protected` | `public` |
| --------- | ----------- | -------- |
| 始终无法通过任何派生访问进行访问 | 如果使用 `private` 派生，则在派生类中为 `private` | 如果使用 `private` 派生，则在派生类中为 `private` |
| | 如果使用 `protected` 派生，则在派生类中为 `protected` | 如果使用 `protected` 派生，则在派生类中为 `protected` |
| | 如果使用 `public` 派生，则在派生类中为 `protected` | 如果使用 `public` 派生，则在派生类中为 `public` |

union 类型不能有基类

在将基类指定为 `private` 时，它只影响非静态成员, 在派生类中， Public 静态成员仍是可访问的。 但是，使用指针、引用或对象访问基类的成员需要转换，此时将再次应用访问控制

适用于 `virtual` 函数的访问控制是由用于进行函数调用的类型决定的。 重写函数的声明不会影响给定类型的访问控制

## 静态成员

可将数据成员声明为静态，这表示类的所有对象都有权访问它的同一副本

可将成员函数声明为静态，在这种情况下它只能访问类的静态数据成员（且不具有 this 指针）

静态数据成员不是给定的类类型的对象的一部分。 因此，静态数据成员的声明不被视为一个定义。 在类范围中声明数据成员，但在文件范围内执行定义。 这些静态类成员具有外部链接

静态数据成员遵循类成员访问规则，因此只允许类成员函数和友元拥有对静态数据成员的私有访问权限。 这些规则在成员访问控制中介绍。 例外情况是，无论静态数据成员的访问限制如何，都必须在文件范围内进行定义。 如果进行显式初始化数据成员，则必须使用定义提供初始值设定项

## 特殊成员函数

- 默认构造函数
- 复制构造函数
- 移动构造函数
- 析构函数
- 复制赋值运算符
- 移动赋值运算符

## 按成员初始化

在 C++ 11 和更高版本中，非静态成员声明符可以包含初始值设定项

如果在构造函数中对成员赋值，则该值将覆盖声明时指定的值

并不总是需要为 class 定义构造函数，特别是相对比较简单的类。 用户可以使用统一初始化来初始化 class 或 struct 的对象，如下面的示例所示：

如果 `class` 或 `struct` 没有构造函数，请按 `class` 中声明的成员的顺序提供列表元素

如果 `class` 具有构造函数，请按参数顺序提供元素

如果类型具有隐式或显式声明的默认构造函数，你可以使用大括号初始化（具有空大括号）对其进行调用。 例如，可通过使用空大括号和非空大括号初始化来初始化以下 class

如果类具有非默认构造函数，则类成员在大括号初始值设定项中的显示顺序是对应参数在构造函数中的显示顺序，而不是成员的声明顺序（如上一示例中的 class_a 一样）。 否则，如果类型没有声明的构造函数，则成员初始值设定项必须按声明的顺序显示在大括号初始值设定项中。 在这种情况下，可以根据需要初始化尽可能多的公共成员，但不能跳过任何成员。 以下示例演示了在无声明的构造函数时在大括号初始化中使用的顺序：

如果默认构造函数已显式声明，但标记为“已删除”，则无法使用空大括号初始化：

可以在通常进行初始化的任何位置使用大括号初始化 - 例如，初始化为函数参数或返回值，或使用 new 关键字初始化：

initializer_list 构造函数

initializer_list 类表示可以在构造函数和其他上下文中使用的指定类型的对象的列表。 您可通过使用大括号初始化构造 initializer_list：

```cpp
initializer_list<int> int_list{5, 6, 7};
```

可以复制 initializer_list。 在这种情况下，新列表的成员是对原始列表成员的引用：

```cpp
initializer_list<int> int_list{5, 6, 7};
initializer_list<int> int_list2(int_list);
```

标准库容器类以及 string、wstring 和 regex 具有 initializer_list 构造函数。 以下示例演示如何使用这些构造函数执行大括号初始化：

```cpp
vector<int> v1{ 1, 2, 3 };
vector<int> v2 = { 1, 2, 3 };
vector<int> v3{ 4, 5, 6 };
vector<int> v4 = v3;
vector<int> v5(v3);
```

## RAII

C++ 没有自动回收垃圾，自动回收垃圾是在程序运行时释放堆内存和其他资源的一个内部进程。 C++ 程序负责将所有已获取的资源返回到操作系统.未能释放未使用的资源称为“泄漏”。 在进程退出之前，泄漏的资源无法用于其他程序。 特别是内存泄漏是 C 样式编程中 bug 的常见原因

新式 C++ 通过声明堆栈上的对象，尽可能避免使用堆内存。 当某个资源对于堆栈来说太大时，则它应由对象拥有。 当该对象初始化时，它会获取它拥有的资源。 然后，该对象负责在其析构函数中释放资源。 在堆栈上声明拥有资源的对象本身。 对象拥有资源的原则也称为“资源获取即初始化”(RAII)

当拥有资源的堆栈对象超出范围时，会自动调用其析构函数。 这样，C++ 中的垃圾回收与对象生存期密切相关，是确定性的。 资源始终在程序中的已知点发布，你可以控制该点。 仅类似 C++ 中的确定析构函数可公平处理内存和非内存资源。

下面的示例显示了简单查询 w。 它在函数范围内的堆栈上声明，并在函数块的末尾销毁。 对象 w 没有资源（例如堆分配的内存）。 它的唯一成员 g 本身在堆栈上声明，并且与 w 一起超出范围。 widget 析构函数中不需要特殊代码

自 C++11 以来，有一种更好的方法可以编写前面的示例：使用标准库中的智能指针。 智能指针可处理对其拥有的内存的分配和删除。 使用智能指针将不需要在 widget 类中显式析构函数

使用智能指针进行内存分配，可以消除内存泄漏的可能性。 此模型适用于其他资源，例如文件句柄或套接字。 可以在你的类中以类似的方式管理自己的资源。 有关详细信息，请参阅智能指针。

C++ 的设计可确保对象在超出范围时被销毁。 也就是说，它们在块被退出时以与构造相反的顺序被摧毁。 销毁对象时，将按特定顺序销毁其基项和成员。 在全局范围内在任何块之外声明的对象可能会导致问题。 如果全局对象的构造函数引发异常，将很难调试

## 结构体内存布局

成员顺序: 结构体的成员变量在内存中按它们声明的顺序依次排列。
数据对齐: 为了提高访问速度，编译器会根据目标平台的要求对结构体成员进行对齐。这可能导致在成员之间或结构体末尾存在填充字节（padding）。
对齐规则通常要求一个类型的数据地址必须是其大小的整数倍。例如，一个4字节的int通常需要放置在地址为4的倍数的位置上。
#pragma pack或编译器特定属性可用于改变或禁用默认的对齐行为。
继承: 如果结构体是从一个或多个其他结构体/类继承而来，则基类的成员将首先出现在派生类对象的内存中，后面跟着派生类自己的成员。
虚函数: 如果结构体有虚函数，编译器通常会在结构体的内存布局中加入一个指向虚函数表（vtable）的指针。这个指针位于对象的开始处，但具体位置取决于编译器的实现。
虚继承: 使用虚继承时，为了解决菱形继承问题，编译器会采取复杂的策略来安排内存布局，这通常涉及额外的指针和调整对象模型。
静态成员: 静态成员变量不作为结构体的一部分存储在每个对象的内存中，它们在全局/静态存储区有单独的存储空间。
位域: 如果结构体使用了位域，则相邻的位域可以被紧密打包以减少空间占用。但是，如果跨越了底层类型的边界，位域可能会被分割开。
零大小数组: 某些编译器允许在结构体末尾使用零大小数组作为柔性数组成员（flexible array member），而这通常不占用结构体的内存空间，只是作为一个符号占位符

## 结构体内存对齐

C++中的结构体内存对齐是为了提高内存访问效率而采用的一种内存布局优化方式。在结构体中，根据处理器的架构和编译器设定的规则，可能会自动插入填充字节（padding），以确保结构体的成员变量按照一定的对齐方式存储。

以下是结构体内存对齐的基本原则：

结构体的起始地址能够被其最宽基本类型成员的大小所整除。
结构体中每个成员相对于结构体起始地址的偏移量（offset）都是该成员类型大小的整数倍，这就可能造成内存空间的浪费，即前面提到的填充字节。
结构体的总大小为结构体最宽基本类型成员大小的整数倍，如果不足，会在结构体末尾添加填充字节。
如果结构体中包含其他结构体或联合体，那么也需要按照这些内部结构体或联合体的对齐要求来对齐。

```cpp
struct MyStruct {
    char a;        // 1字节
    int b;         // 4字节
    short c;       // 2字节
};
```

在上述结构体中，int 类型通常需要按照4字节对齐，在32位或64位架构下。假设编译器按照4字节对齐规则对该结构体进行内存对齐，则实际内存布局可能如下：

char a; 占用1字节，后面跟着3字节的填充，以确保接下来的 int b; 能在4字节边界上对齐。
int b; 直接按照4字节对齐，紧接着 char a; 后面的填充字节。
short c; 占用2字节，并且因为已经处于4字节边界上，所以不需要额外填充。

结构体总大小：sizeof(MyStruct) 很可能是8个字节（1字节char + 3字节填充 + 4字节int），但实际上还有一个2字节的short，所以需要再加上2个字节的填充，使得整个结构体大小为12字节，满足最大对齐成员int的4字节的整数倍。

记住，具体的对齐情况取决于编译器设置（例如GCC的__attribute__((packed))、#pragma pack等）和目标平台的硬件架构。开发者可以通过这些手段来修改默认的对齐规则，以满足特定的内存或性能要求
