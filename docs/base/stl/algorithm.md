# Algorithm

C++ 标准库算法可以针对各种数据结构进行操作
可用 C++ 标准库运算的数据结构不仅包括 C++ 标准库容器类（例如vector和list），还包括用户定义的数据结构和元素数组（只要它们满足特定算法的要求）
C++ 标准库算法通过迭代器间接访问并遍历容器元素来实现这种通用性

C++ 标准库算法处理迭代器范围通常是由其开始或末尾位置指定。 引用的范围必须有效，即范围中的所有迭代器必须可以取消引用，并且在每个范围的序列中，必须通过递增迭代器从第一个位置递增到达最后一个位置

从 C++20 开始，`<algorithm>` 中定义的大多数算法也以采用 `range` 的形式提供。 例如，可以调用 `ranges::sort(v1, greater<int>());`，而不调用`sort(v1.begin(), v1.end(), greater<int>())`;

C++ 标准库算法可以同时处理不同类型的容器对象。 两个后缀已用于传递与算法目的相关的信息：

- `_if` 后缀指示将算法用于对元素的值（而非元素本身）产生作用的函数对象。 例如，`find_if` 算法查找其值满足函数对象指定的条件的元素，而`find`算法搜索特定值
- `_copy`后缀指示算法通常修改复制的值，而不是复制修改的值。 换句话说，它们不会修改源范围的元素，而是将结果放入输出范围/迭代器中。 例如，`reverse`算法反向排序范围中的元素，而`reverse_copy`算法将反向结果复制到目标范围

C++ 标准库算法通常进行分组以指示其目的或需求。 这些包括更改元素值的修改算法和不更改元素值的非修改算法。 改变算法将更改元素顺序，但不更改其元素的值。 移除算法可将元素从范围或范围副本中消除。 排序算法以各种方式对范围内的元素重新排序，而排序范围算法只作用于以特定方式排序的元素的范围

为数值处理提供的 C++ 标准库数值算法具有自己的标头文件 `<numeric>`，而函数对象和适配器则在标头 `<functional>` 中定义。 返回布尔值的函数对象称为谓词。 默认二元谓词是比较 operator<。 通常，排序的元素需小于比较元素，因此，给定任意两个元素，可以确定它们是等效的（即两者都不小于对方）或其中一个小于另一个。 这将导致在非等效元素之间进行排序

## 算法

| 算法 | 描述 |
| --- | --- |
| adjacent_find | 搜索相等或满足指定条件的两个相邻元素 |
| all_of | 当给定范围中的每个元素均满足条件时返回 `true` |
| any_of | 当指定元素范围中至少有一个元素满足条件时返回 `true` |
| binary_search | 测试已排序的范围中是否有等于指定值的元素，或在二元谓词指定的意义上与指定值等效的元素 |
| copy | 将一个源范围中的元素值分配到目标范围，循环访问元素的源序列并将它们分配在一个向前方向的新位置 |
| copy_backward | 将一个源范围中的元素值分配到目标范围，循环访问元素的源序列并将它们分配在一个向后方向的新位置 |
| copy_if | 复制给定范围中对于指定条件为 `true` 的所有元素 |
| copy_n | 复制指定数量的元素 |
| count | 返回范围中其值与指定值匹配的元素的数量 |
| count_if | 返回范围中其值与指定条件匹配的元素的数量 |
| equal | 逐个元素比较两个范围是否相等或是否在二元谓词指定的意义上等效 |

