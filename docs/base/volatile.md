# volatile

可用于声明可在程序中由硬件修改的对象的类型限定符

易变性。所谓的易变性，在汇编层面反映出来，就是两条语句，下一条语句不会直接使用上一条语句对应的volatile变量的寄存器内容，而是重新从内存中读取
Volatile关键词的第二个特性：“不可优化”特性。volatile告诉编译器，不要对我这个变量进行各种激进的优化，甚至将变量直接消除，保证程序员写在代码中的指令，一定会被执行。 Volatile关键词的第三个特性：”顺序性”，能够保证Volatile变量间的顺序性，编译器不会进行乱序优化。 C/C++ Volatile变量，与非Volatile变量之间的操作，是可能被编译器交换顺序的。C/C++ Volatile变量间的操作，是不会被编译器交换顺序的。哪怕将所有的变量全部都声明为volatile，哪怕杜绝了编译器的乱序优化，但是针对生成的汇编代码，CPU有可能仍旧会乱序执行指令，导致程序依赖的逻辑出错，volatile对此无能为力 针对这个多线程的应用，真正正确的做法，是构建一个happens-before语义

可以使用 /volatile 编译器开关来修改编译器解释此关键字的方式

Visual Studio 根据目标体系结构以不同的方式解释 volatile 关键字。 对于 ARM，如果未指定 /volatile 编译器选项，则编译器的执行方式就如同指定了 /volatile:iso 一样。 对于 ARM 之外的体系结构，如果未指定 /volatile 编译器选项，则编译器的执行方式就如同指定了 /volatile:ms 一样；因此，对于 ARM 之外的体系结构，我们强烈建议在处理跨线程共享的内存时，指定 /volatile:iso，并使用显式同步基元和编译器内部函数
