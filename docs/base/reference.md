# 引用

与指针相似的是，引用将存储位于内存中其他位置的对象的地址
与指针不同，初始化之后的引用无法引用不同的对象或设置为 null
有两种类型的引用：

- 引用命名变量的 lvalue 引用
- 引用临时对象的 rvalue 引用
- & 运算符表示 lvalue 引用
- && 运算符表示 rvalue 引用或通用引用（rvalue 或 lvalue），具体取决于上下文

## 声明

```cpp
int x = 1;
int& y = x;
int &i;
int &i, &j;
int &ref, *ptr, k;
```

## Lvalues 和 Rvalues

每个 C++ 表达式都有一个类型，属于值类别
值类别是编译器在表达式计算期间创建、复制和移动临时对象时必须遵循的规则的基础

C++17 标准对表达式值类别的定义如下：

glvalue 是一个表达式，它的计算可以确定对象、位域或函数的标识。
prvalue 是一个表达式，它的计算可以初始化对象或位域，或计算运算符的操作数值，这是由它出现的上下文所指定的。
xvalue 是一个 glvalue，表示一个对象或位域，该对象或位域的资源可重复使用（通常是因为它接近其生存期的末尾）。 示例：某些涉及 rvalue 引用 (8.3.2) 的类型的表达式会生成 xvalue，例如对返回类型为 rvalue 引用或强制转换为 rvalue 引用类型的函数的调用。
lvalue 为非 xvalue 的 glvalue。
rvalue 是一个 prvalue 或 xvalue。

lvalue 具有程序可访问的地址。 例如，lvalue 表达式包括变量名称，其中包括 const 变量、数组元素、返回 lvalue 引用的函数调用、位域、联合和类成员。

prvalue 表达式没有可供程序访问的地址。 例如，prvalue 表达式包括文本、可返回非引用类型的函数调用，以及在表达式计算期间创建的但只能由编译器访问的临时对象。

xvalue 表达式有一个地址，该地址不再可供程序访问，但可用于初始化 rvalue 引用，以提供对表达式的访问。 例如，它包括可返回 rvalue 引用的函数调用，以及数组下标、成员和指向其中数组或对象是 rvalue 引用的成员表达式的指针



## Lvalue 引用声明符：&

保留对象的地址，但行为方式在语法上与对象相似

您可以将左值引用视为对象的另一名称。 左值引用声明由说明符的可选列表后跟一个引用声明符组成。 引用必须初始化且无法更改

地址可转换为给定指针类型的任何对象也可转换为相似的引用类型。 例如，地址可转换为类型 char * 的任何对象也可转换为类型 char &

不要将引用声明与 address-of 运算符的用法混淆。 &identifier 前面有 int 或 char 之类的类型时，identifier 将声明为对该类型的引用。 &identifier 前面没有类型时，用法就是 address-of 运算符的用法

## Rvalue 引用声明符：&&

保留对右值表达式的引用

利用右值引用，您可以将左值与右值区分开。 lvalue 引用和 rvalue 引用在语法和语义上相似，但它们遵循的规则稍有不同

- 移动语义

Rvalue 引用支持“移动语义”的实现，这可以显著提高应用程序的性能。 利用移动语义，你可以编写将资源（如动态分配的内存）从一个对象转移到另一个对象的代码。 移动语义很有效，因为它允许从临时对象（无法在程序中的其他位置引用）转移资源



- 完美转发
- 通用引用
- 右值引用变量是左值

向函数传递引用而非大型对象的效率通常更高。 这使编译器能够在保持已用于访问对象的语法的同时传递对象的地址
通过引用传递的结构的成员是通过成员选择运算符 (.) 访问的，而不是通过指针成员选择运算符 (->) 访问的
尽管作为引用类型传递的参数遵循了非指针类型的语法，但它们仍然保留了指针类型的一个重要特征：除非被声明为 const，否则它们是可以修改的
任何其原型采用引用类型的函数都能接受其所在位置的相同类型的对象，因为存在从 typename 到 typename& 的标准转换

## 对指针的引用

声明对指针的引用的方式与声明对对象的引用差不多。 对指针的引用是一个可像常规指针一样使用的可修改的值
