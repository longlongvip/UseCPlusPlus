# C++ 类型系统

在 C++ 中，类型的概念非常重要。 每个变量、函数自变量和函数返回值必须具有一个类型以进行编译

## 类型分类

标量类型：包含定义范围的单个值的类型。 标量包括算术类型（整型或浮点值）、枚举类型成员、指针类型、指针到成员类型以及 std::nullptr_t。 基本类型通常是标量类型
复合类型：不是标量类型的类型。 复合类型包括数组类型、函数类型、类（或结构）类型、联合类型、枚举、引用和指向非静态类成员的指针
变量：数据量的符号名称。 该名称可用于访问它在整个定义代码范围内引用的数据。 在 C++ 中，变量通常用于指标量数据类型的实例，而其他类型的实例通常称为对象
对象：为了简洁一致，本文使用术语“对象”指代类或结构的任何实例。 在一般意义上使用时，它包括所有类型，甚至标量变量
POD 类型（纯旧数据）：C++ 中的此类非正式数据类型类别是指作为标量（参见基础类型部分）的类型或 POD 类。 POD 类没有不是 POD 的静态数据成员，没有用户定义的构造函数、用户定义的析构函数或用户定义的赋值运算符。 此外，POD 类无虚函数、基类、私有的或受保护的非静态数据成员。 POD 类型通常用于外部数据交换，例如与用 C 语言编写的模块（仅具有 POD 类型）进行的数据交换

## 基本类型

## void 类型

void 类型是一种特殊类型；不能声明 void 类型的变量，但可声明 void * 类型的变量（指向 void 的指针），有时当分配原始（非类型化）内存时这样做很有必要。 但是，指向 void 的指针不是类型安全的指针，建议不要在新式 C++ 中使用它们。 在函数声明中，void 返回值意味着该函数不返回值；将其用作返回类型是 void 的常见且可接受的用法。 尽管 C 语言需要含零个参数的函数以在参数列表中声明 void（例如 fn(void)），但新式 C++ 中建议不要这样做，而是应声明无参数函数 fn()

## const 类型限定符

任何内置或用户定义的类型都可由 const 关键字限定。 此外，成员函数可受到 const 限定，甚至可重载 const。 const 类型的值在初始化后将无法修改

const 限定符在函数和变量声明中使用广泛，而“常量正确性”是 C++ 中的一个重要概念；它实质上表示使用 const 来确保在编译时不会无意中修改值

const 类型与其非 const 版本截然不同；例如，const int 是与 int 截然不同的类型。 如果发生必须从变量中移除常量性的这类少数情况，可使用 C++ const_cast 运算符

## 字符串类型

严格来说，C++ 语言没有内置的字符串类型；char 和 wchar_t 存储单个字符 - 必须声明这些类型的数组来估计字符串，从而将一个终止 null 值（例如，ASCII '\0'）添加到最后一个有效字符数后的数组元素（也称为“C 样式字符串”）。 C 样式字符串需要编写更多的代码或者需要使用外部字符串实用工具库函数。 但是，在新式 C++ 中，我们具有标准库类型 std::string（用于 8 位 char 型字符串）或 std::wstring（用于 16 位 wchar_t 型字符串）。 这些 C++ 标准库容器可被视为本机字符串类型，因为它们是所有兼容 C++ 生成环境包含的标准库的一部分。 使用 #include <string> 指令使这些类型在你的程序中可用。 （如果使用的是 MFC 或 ATL，还可使用 CString 类，但其不符合 C++ 标准。）建议不要在新式 C++ 中使用 null 终止字符数组（前面提到的 C 样式字符串）。

## 用户定义类型

在定义 class、struct、union 或 enum 时，该构造会在代码的其余部分使用，如同它是一个基础类型一样。 它具有内存的已知大小以及一些有关可以如何在程序生命期内将其用于编译时检查和运行时的规则。 基本内置类型和用户定义的类型之间的主要区别如下：

编译器没有用户定义的类型的内置知识。 它在编译过程中首次遇到此定义时就学习了此类型。

通过定义（通过重载）适当的运算符作为类成员或非成员函数，可以指定可对你的类型执行的操作以及你的类型转换为其他类型的方式。 有关详细信息，请参阅函数重载

## 指针类型

C++ 继续通过使用特殊声明符 *（星号）声明指针类型的变量。 指针类型在存储实际数据值的内存中存储位置地址。 在新式 C++ 中，这些指针类型称为原始指针，它们通过特殊运算符在代码中访问：*（星号）或 ->（带大于号的短划线，通常称为箭头）。 此内存访问操作称为取消引用。 所使用的运算符取决于是取消引用指向标量指针的指针，还是取消引用指向对象中成员的指针

使用指针类型很长时间以来都是 C 和 C++ 程序开发的最具挑战性和最难以理解的方面之一。 本节概述了一些事实和实践，以帮助你在需要时使用原始指针。 但是，在新式 C++ 中，由于智能指针的演变（在本部分末尾进行了更多讨论），因此不再需要（或建议）将原始指针用于对象所有权。 使用原始指针来观察对象仍然是有用和安全的。 但是，如果必须将其用于对象所有权，则需要谨慎操作，并仔细考虑如何创建和销毁其拥有的对象

首先应知道的是，原始指针变量声明只分配足够的内存来存储地址：指针在取消引用时引用的内存位置。 指针声明不会分配存储数据值所需的内存。 （该内存也称为后备存储。）换言之，通过声明原始指针变量，将创建内存地址变量而非实际数据变量。 如果在确保指针变量包含后备存储的有效地址前取消对其的引用，则将导致程序发生未定义行为（通常为严重错误）。 下面的示例演示了此种错误

该示例取消引用指针类型，未分配用于存储实际整数数据的任何内存或向其分配有效内存地址。 下面的代码更正这些错误：

已纠正的代码示例使用本地堆栈内存创建 pNumber 指向的后备存储。 我们使用基本类型，以求简单。 实际上，指针的后备存储通常是用户定义类型，这些类型通过使用 new 关键字表达式（在 C 样式编程中，使用旧的 malloc() C 运行时库函数）动态分配到称为“堆”（或“可用存储”）的内存区域中。 分配后，这些变量通常指“对象”，尤其是基于类定义这些变量的情况下。 使用 new 分配的内存必须由相应的 delete 语句删除（如果使用 malloc() 函数进行关联，则使用 C 运行时函数 free() 执行删除操作）

但是，很容易忘记删除动态分配的对象（特别是在复杂代码中），这会导致产生名为“内存泄漏”的资源 Bug。 为此，建议你不要在新式 C++ 中使用原始指针。 在智能指针中包装原始指针几乎总是更好的，该指针在调用其析构函数时自动释放内存。 （也就是说，当代码超出智能指针的范围时。）通过使用智能指针，几乎消除了 C++ 程序中的一系列 bug。 在下面的示例中，假定 MyClass 是具有公共方法 DoSomeWork(); 的用户定义的类型

## Windows 数据类型

在 C 和 C++ 的经典 Win32 编程中，大多数函数使用 Windows 特定的 Typedef 和 #define 宏（在 windef.h 中定义）来指定参数类型和返回值。 这些 Windows 数据类型通常是为 C/C++ 内置类型提供的特殊名称（别名）。 有关这些 typedef 和预处理器定义的完整列表，请参阅 Windows 数据类型。 其中一些 typedef（例如 HRESULT 和 LCID）很有用且具有描述性。 INT 等其他类型没有特殊含义，只是基础 C++ 类型的别名。 其他 Windows 数据类型的名称自 C 编程和 16 位处理器得到保留，并且在现代硬件或操作系统中不具有目的和意义。 还有与 Windows 运行时库相关的特定数据类型，它们在列表中显示为 Windows 运行时基础数据类型。 在新式 C++ 中，一般准则是首选 C++ 基本类型，除非 Windows 类型传达一些有关如何解释值的额外意义
