# auto 与类型推导

## 解释 auto 类型推到

auto 类型推导通常与模板类型推导相同，但 auto 类型推导假定用大括号括起来的初始化器代表 std::initializer_list，而模板类型推导并不持有这样的前提

以下是几个示例：

```cpp
int* ip;
auto  aip = ip;       // aip是一个指向整数的指针
const  int* cip;
auto  acip = cip;      // acip是一个指向常量整数的指针（值不能修改，但它所指向的内存地址可以修改）
const  int* const  cicp = ip;
auto  acicp = cicp;    // acicp仍然是一个指向常量整数的指针，指针的常量性被丢弃

auto  x = 27;          // （x既不是指针也不是引用），x的类型是int
const  auto  cx = x;   // （cx既不是指针也不是引用），cx的类型是const int
const  auto& rx = x;   // （rx是一个非万能引用），rx的类型是指向const int的引用
auto&& uref1 = x;      // x是int且为左值，所以uref1的类型是int&
auto&& uref2 = cx;     // cx是const int且为左值，所以uref2的类型是const int&
auto&& uref3 = 27;     // 27是int且为右值，所以uref3的类型是int&&

auto  x3 = { 27 };     // 类型是std::initializer_list<int>，值是{27}
auto  x4{ 27 };        // 类型是std::initializer_list<int>，值是{27}
// 在某些编译器中，类型可能会被推导为int，值为27。更多信息见注释。
auto  x5 = { 1, 2.0 }; // 错误！无法为std::initializer_list<T>推导T的类型

```

可以看出，如果使用大括号初始化器，auto会强制创建一个std::initializer_list类型的变量。如果它无法推导出T的类型，代码就会被拒绝

我们也看到，auto可以为指针推导出正确的类型，但为了得到引用，我们必须写成auto&。为了保持一致性，如果我们期望得到一个指针，也可以写成auto*

在函数返回类型或lambda参数中使用auto意味着进行模板类型推导，而非auto类型推导

## auto 在何时会推导出不理想的类型？

“不可见”的代理类型会导致auto为初始化表达式推导出 “错误” 的类型。std::vector<bool>就是这样一种类型。如果有一个函数返回这种类型，而你只对其中一位信息感兴趣，想用auto声明一个变量来保存它，之后又想使用这个bool类型向量中的某个元素，这会产生未定义行为

当你想要的类型精度低于函数返回的类型时，也会出现类似问题，比如当你知道可能的输出范围，想节省一些内存时。例如，一个函数返回double类型，但你想要float类型。使用auto不会进行隐式转换，但你可以用上述习惯用法强制转换。

## 使用auto有哪些优点？

auto变量必须初始化，因此它们通常不会出现可能导致可移植性或效率问题的类型不匹配情况。auto还能让重构更轻松，并且通常比显式指定类型输入的内容更少

auto变量主要可以提高正确性、性能、可维护性和健壮性。输入起来也更方便，但这是它最不重要的优点

当你确实想显式指定类型时，可以考虑声明局部变量auto x = type{ expr };。这样做能表明代码是在明确请求转换，具有自文档化的作用，并且能保证变量被初始化，此外，它还能防止意外的隐式窄化转换。只有当你确实想要显式窄化时，才使用()而不是{}

如果你担心可读性，前面提到的技巧会有帮助，否则你不必为此烦恼，现代的集成开发环境（IDE）会在你将鼠标悬停在变量上时显示其确切类型。

对于局部变量，如果你使用auto x = expr;这种声明方式，有很多优点：

能保证你的变量被初始化。如果你忘了初始化，编译器会报错。
没有临时对象和隐式转换，因此效率更高。
使用auto能保证你使用正确的类型。
在维护和重构时，无需更新类型。
对于内置类型的算术运算，这是一种可移植地表示特定于实现的类型的最简单方法。这些类型可能因平台而异，使用auto还能确保不会意外出现有损的窄化转换。

你可以省略难以书写的类型，比如lambda表达式、迭代器等

## 解释一下decltype

decltype是一个关键字，用于查询变量或表达式的类型。它在C++11中被引入，主要用于泛型编程，在泛型编程中，要表达依赖于模板参数的类型通常很困难，甚至是不可能的

给定一个名称或表达式，decltype会告知你该名称或表达式的类型



## 将两个bool类型相加会得到什么数据类型？

int 类型
